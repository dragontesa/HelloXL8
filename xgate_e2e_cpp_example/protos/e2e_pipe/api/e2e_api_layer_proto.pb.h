// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: e2e_api_layer_proto.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_e2e_5fapi_5flayer_5fproto_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_e2e_5fapi_5flayer_5fproto_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/api/annotations.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_e2e_5fapi_5flayer_5fproto_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_e2e_5fapi_5flayer_5fproto_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_e2e_5fapi_5flayer_5fproto_2eproto;
namespace e2e_pipe {
namespace api {
class E2eApiAudioDataFormat;
struct E2eApiAudioDataFormatDefaultTypeInternal;
extern E2eApiAudioDataFormatDefaultTypeInternal _E2eApiAudioDataFormat_default_instance_;
class E2eApiCloseRequest;
struct E2eApiCloseRequestDefaultTypeInternal;
extern E2eApiCloseRequestDefaultTypeInternal _E2eApiCloseRequest_default_instance_;
class E2eApiCloseResponse;
struct E2eApiCloseResponseDefaultTypeInternal;
extern E2eApiCloseResponseDefaultTypeInternal _E2eApiCloseResponse_default_instance_;
class E2eApiData;
struct E2eApiDataDefaultTypeInternal;
extern E2eApiDataDefaultTypeInternal _E2eApiData_default_instance_;
class E2eApiDataFormat;
struct E2eApiDataFormatDefaultTypeInternal;
extern E2eApiDataFormatDefaultTypeInternal _E2eApiDataFormat_default_instance_;
class E2eApiData_MultilingualTextEntry_DoNotUse;
struct E2eApiData_MultilingualTextEntry_DoNotUseDefaultTypeInternal;
extern E2eApiData_MultilingualTextEntry_DoNotUseDefaultTypeInternal _E2eApiData_MultilingualTextEntry_DoNotUse_default_instance_;
class E2eApiError;
struct E2eApiErrorDefaultTypeInternal;
extern E2eApiErrorDefaultTypeInternal _E2eApiError_default_instance_;
class E2eApiInitRequest;
struct E2eApiInitRequestDefaultTypeInternal;
extern E2eApiInitRequestDefaultTypeInternal _E2eApiInitRequest_default_instance_;
class E2eApiInitRequest_OptionsEntry_DoNotUse;
struct E2eApiInitRequest_OptionsEntry_DoNotUseDefaultTypeInternal;
extern E2eApiInitRequest_OptionsEntry_DoNotUseDefaultTypeInternal _E2eApiInitRequest_OptionsEntry_DoNotUse_default_instance_;
class E2eApiInitResponse;
struct E2eApiInitResponseDefaultTypeInternal;
extern E2eApiInitResponseDefaultTypeInternal _E2eApiInitResponse_default_instance_;
class E2eApiTextDataFormat;
struct E2eApiTextDataFormatDefaultTypeInternal;
extern E2eApiTextDataFormatDefaultTypeInternal _E2eApiTextDataFormat_default_instance_;
class E2eApiTransRequest;
struct E2eApiTransRequestDefaultTypeInternal;
extern E2eApiTransRequestDefaultTypeInternal _E2eApiTransRequest_default_instance_;
class E2eApiTransResponse;
struct E2eApiTransResponseDefaultTypeInternal;
extern E2eApiTransResponseDefaultTypeInternal _E2eApiTransResponse_default_instance_;
class E2eApiWebhookConfig;
struct E2eApiWebhookConfigDefaultTypeInternal;
extern E2eApiWebhookConfigDefaultTypeInternal _E2eApiWebhookConfig_default_instance_;
}  // namespace api
}  // namespace e2e_pipe
PROTOBUF_NAMESPACE_OPEN
template<> ::e2e_pipe::api::E2eApiAudioDataFormat* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiAudioDataFormat>(Arena*);
template<> ::e2e_pipe::api::E2eApiCloseRequest* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiCloseRequest>(Arena*);
template<> ::e2e_pipe::api::E2eApiCloseResponse* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiCloseResponse>(Arena*);
template<> ::e2e_pipe::api::E2eApiData* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiData>(Arena*);
template<> ::e2e_pipe::api::E2eApiDataFormat* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiDataFormat>(Arena*);
template<> ::e2e_pipe::api::E2eApiData_MultilingualTextEntry_DoNotUse* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiData_MultilingualTextEntry_DoNotUse>(Arena*);
template<> ::e2e_pipe::api::E2eApiError* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiError>(Arena*);
template<> ::e2e_pipe::api::E2eApiInitRequest* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiInitRequest>(Arena*);
template<> ::e2e_pipe::api::E2eApiInitRequest_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiInitRequest_OptionsEntry_DoNotUse>(Arena*);
template<> ::e2e_pipe::api::E2eApiInitResponse* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiInitResponse>(Arena*);
template<> ::e2e_pipe::api::E2eApiTextDataFormat* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiTextDataFormat>(Arena*);
template<> ::e2e_pipe::api::E2eApiTransRequest* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiTransRequest>(Arena*);
template<> ::e2e_pipe::api::E2eApiTransResponse* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiTransResponse>(Arena*);
template<> ::e2e_pipe::api::E2eApiWebhookConfig* Arena::CreateMaybeMessage<::e2e_pipe::api::E2eApiWebhookConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace e2e_pipe {
namespace api {

enum ApiType : int {
  SPEECH_TO_SPEECH = 0,
  SPEECH_TO_TEXT = 1,
  TEXT_TO_SPEECH = 2,
  ApiType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ApiType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ApiType_IsValid(int value);
constexpr ApiType ApiType_MIN = SPEECH_TO_SPEECH;
constexpr ApiType ApiType_MAX = TEXT_TO_SPEECH;
constexpr int ApiType_ARRAYSIZE = ApiType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ApiType_descriptor();
template<typename T>
inline const std::string& ApiType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ApiType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ApiType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ApiType_descriptor(), enum_t_value);
}
inline bool ApiType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ApiType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ApiType>(
    ApiType_descriptor(), name, value);
}
enum Timeliness : int {
  REALTIME = 0,
  BATCH = 1,
  INTERPRETING = 2,
  Timeliness_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Timeliness_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Timeliness_IsValid(int value);
constexpr Timeliness Timeliness_MIN = REALTIME;
constexpr Timeliness Timeliness_MAX = INTERPRETING;
constexpr int Timeliness_ARRAYSIZE = Timeliness_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Timeliness_descriptor();
template<typename T>
inline const std::string& Timeliness_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Timeliness>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Timeliness_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Timeliness_descriptor(), enum_t_value);
}
inline bool Timeliness_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Timeliness* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Timeliness>(
    Timeliness_descriptor(), name, value);
}
enum E2eApiResponseType : int {
  E2E_API_RESPONSE_SUCCESS = 0,
  E2E_API_RESPONSE_ERROR = 1,
  E2eApiResponseType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  E2eApiResponseType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool E2eApiResponseType_IsValid(int value);
constexpr E2eApiResponseType E2eApiResponseType_MIN = E2E_API_RESPONSE_SUCCESS;
constexpr E2eApiResponseType E2eApiResponseType_MAX = E2E_API_RESPONSE_ERROR;
constexpr int E2eApiResponseType_ARRAYSIZE = E2eApiResponseType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* E2eApiResponseType_descriptor();
template<typename T>
inline const std::string& E2eApiResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, E2eApiResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function E2eApiResponseType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    E2eApiResponseType_descriptor(), enum_t_value);
}
inline bool E2eApiResponseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, E2eApiResponseType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<E2eApiResponseType>(
    E2eApiResponseType_descriptor(), name, value);
}
// ===================================================================

class E2eApiData_MultilingualTextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<E2eApiData_MultilingualTextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<E2eApiData_MultilingualTextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  E2eApiData_MultilingualTextEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR E2eApiData_MultilingualTextEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit E2eApiData_MultilingualTextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const E2eApiData_MultilingualTextEntry_DoNotUse& other);
  static const E2eApiData_MultilingualTextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const E2eApiData_MultilingualTextEntry_DoNotUse*>(&_E2eApiData_MultilingualTextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "e2e_pipe.api.E2eApiData.MultilingualTextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "e2e_pipe.api.E2eApiData.MultilingualTextEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};

// -------------------------------------------------------------------

class E2eApiData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiData) */ {
 public:
  inline E2eApiData() : E2eApiData(nullptr) {}
  ~E2eApiData() override;
  explicit PROTOBUF_CONSTEXPR E2eApiData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiData(const E2eApiData& from);
  E2eApiData(E2eApiData&& from) noexcept
    : E2eApiData() {
    *this = ::std::move(from);
  }

  inline E2eApiData& operator=(const E2eApiData& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiData& operator=(E2eApiData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiData& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kAudio = 1,
    kText = 2,
    DATA_NOT_SET = 0,
  };

  static inline const E2eApiData* internal_default_instance() {
    return reinterpret_cast<const E2eApiData*>(
               &_E2eApiData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(E2eApiData& a, E2eApiData& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiData& from) {
    E2eApiData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiData";
  }
  protected:
  explicit E2eApiData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMultilingualTextFieldNumber = 7,
    kOriginalFieldNumber = 4,
    kTimeStartMsecFieldNumber = 5,
    kTimeEndMsecFieldNumber = 6,
    kIsPartialFieldNumber = 3,
    kAudioFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // map<string, string> multilingual_text = 7;
  int multilingual_text_size() const;
  private:
  int _internal_multilingual_text_size() const;
  public:
  void clear_multilingual_text();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_multilingual_text() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_multilingual_text();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      multilingual_text() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_multilingual_text();

  // string original = 4;
  void clear_original();
  const std::string& original() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original();
  PROTOBUF_NODISCARD std::string* release_original();
  void set_allocated_original(std::string* original);
  private:
  const std::string& _internal_original() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original(const std::string& value);
  std::string* _internal_mutable_original();
  public:

  // uint64 time_start_msec = 5;
  void clear_time_start_msec();
  uint64_t time_start_msec() const;
  void set_time_start_msec(uint64_t value);
  private:
  uint64_t _internal_time_start_msec() const;
  void _internal_set_time_start_msec(uint64_t value);
  public:

  // uint64 time_end_msec = 6;
  void clear_time_end_msec();
  uint64_t time_end_msec() const;
  void set_time_end_msec(uint64_t value);
  private:
  uint64_t _internal_time_end_msec() const;
  void _internal_set_time_end_msec(uint64_t value);
  public:

  // bool is_partial = 3;
  void clear_is_partial();
  bool is_partial() const;
  void set_is_partial(bool value);
  private:
  bool _internal_is_partial() const;
  void _internal_set_is_partial(bool value);
  public:

  // bytes audio = 1;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const std::string& audio() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio();
  PROTOBUF_NODISCARD std::string* release_audio();
  void set_allocated_audio(std::string* audio);
  private:
  const std::string& _internal_audio() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio(const std::string& value);
  std::string* _internal_mutable_audio();
  public:

  // string text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiData)
 private:
  class _Internal;
  void set_has_audio();
  void set_has_text();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        E2eApiData_MultilingualTextEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> multilingual_text_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_;
    uint64_t time_start_msec_;
    uint64_t time_end_msec_;
    bool is_partial_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiTextDataFormat final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiTextDataFormat) */ {
 public:
  inline E2eApiTextDataFormat() : E2eApiTextDataFormat(nullptr) {}
  explicit PROTOBUF_CONSTEXPR E2eApiTextDataFormat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiTextDataFormat(const E2eApiTextDataFormat& from);
  E2eApiTextDataFormat(E2eApiTextDataFormat&& from) noexcept
    : E2eApiTextDataFormat() {
    *this = ::std::move(from);
  }

  inline E2eApiTextDataFormat& operator=(const E2eApiTextDataFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiTextDataFormat& operator=(E2eApiTextDataFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiTextDataFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiTextDataFormat* internal_default_instance() {
    return reinterpret_cast<const E2eApiTextDataFormat*>(
               &_E2eApiTextDataFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(E2eApiTextDataFormat& a, E2eApiTextDataFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiTextDataFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiTextDataFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiTextDataFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiTextDataFormat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const E2eApiTextDataFormat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const E2eApiTextDataFormat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiTextDataFormat";
  }
  protected:
  explicit E2eApiTextDataFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiTextDataFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiAudioDataFormat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiAudioDataFormat) */ {
 public:
  inline E2eApiAudioDataFormat() : E2eApiAudioDataFormat(nullptr) {}
  ~E2eApiAudioDataFormat() override;
  explicit PROTOBUF_CONSTEXPR E2eApiAudioDataFormat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiAudioDataFormat(const E2eApiAudioDataFormat& from);
  E2eApiAudioDataFormat(E2eApiAudioDataFormat&& from) noexcept
    : E2eApiAudioDataFormat() {
    *this = ::std::move(from);
  }

  inline E2eApiAudioDataFormat& operator=(const E2eApiAudioDataFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiAudioDataFormat& operator=(E2eApiAudioDataFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiAudioDataFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiAudioDataFormat* internal_default_instance() {
    return reinterpret_cast<const E2eApiAudioDataFormat*>(
               &_E2eApiAudioDataFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(E2eApiAudioDataFormat& a, E2eApiAudioDataFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiAudioDataFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiAudioDataFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiAudioDataFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiAudioDataFormat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiAudioDataFormat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiAudioDataFormat& from) {
    E2eApiAudioDataFormat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiAudioDataFormat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiAudioDataFormat";
  }
  protected:
  explicit E2eApiAudioDataFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleRateFieldNumber = 1,
    kChannelsFieldNumber = 2,
  };
  // uint32 sample_rate = 1;
  void clear_sample_rate();
  uint32_t sample_rate() const;
  void set_sample_rate(uint32_t value);
  private:
  uint32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(uint32_t value);
  public:

  // uint32 channels = 2;
  void clear_channels();
  uint32_t channels() const;
  void set_channels(uint32_t value);
  private:
  uint32_t _internal_channels() const;
  void _internal_set_channels(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiAudioDataFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t sample_rate_;
    uint32_t channels_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiDataFormat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiDataFormat) */ {
 public:
  inline E2eApiDataFormat() : E2eApiDataFormat(nullptr) {}
  ~E2eApiDataFormat() override;
  explicit PROTOBUF_CONSTEXPR E2eApiDataFormat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiDataFormat(const E2eApiDataFormat& from);
  E2eApiDataFormat(E2eApiDataFormat&& from) noexcept
    : E2eApiDataFormat() {
    *this = ::std::move(from);
  }

  inline E2eApiDataFormat& operator=(const E2eApiDataFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiDataFormat& operator=(E2eApiDataFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiDataFormat& default_instance() {
    return *internal_default_instance();
  }
  enum FormatCase {
    kTextFormat = 2,
    kAudioFormat = 3,
    FORMAT_NOT_SET = 0,
  };

  static inline const E2eApiDataFormat* internal_default_instance() {
    return reinterpret_cast<const E2eApiDataFormat*>(
               &_E2eApiDataFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(E2eApiDataFormat& a, E2eApiDataFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiDataFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiDataFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiDataFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiDataFormat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiDataFormat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiDataFormat& from) {
    E2eApiDataFormat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiDataFormat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiDataFormat";
  }
  protected:
  explicit E2eApiDataFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalLanguageCodeFieldNumber = 4,
    kLanguageCodeFieldNumber = 1,
    kTextFormatFieldNumber = 2,
    kAudioFormatFieldNumber = 3,
  };
  // repeated string additional_language_code = 4;
  int additional_language_code_size() const;
  private:
  int _internal_additional_language_code_size() const;
  public:
  void clear_additional_language_code();
  const std::string& additional_language_code(int index) const;
  std::string* mutable_additional_language_code(int index);
  void set_additional_language_code(int index, const std::string& value);
  void set_additional_language_code(int index, std::string&& value);
  void set_additional_language_code(int index, const char* value);
  void set_additional_language_code(int index, const char* value, size_t size);
  std::string* add_additional_language_code();
  void add_additional_language_code(const std::string& value);
  void add_additional_language_code(std::string&& value);
  void add_additional_language_code(const char* value);
  void add_additional_language_code(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& additional_language_code() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_additional_language_code();
  private:
  const std::string& _internal_additional_language_code(int index) const;
  std::string* _internal_add_additional_language_code();
  public:

  // string language_code = 1;
  void clear_language_code();
  const std::string& language_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_code();
  PROTOBUF_NODISCARD std::string* release_language_code();
  void set_allocated_language_code(std::string* language_code);
  private:
  const std::string& _internal_language_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_code(const std::string& value);
  std::string* _internal_mutable_language_code();
  public:

  // .e2e_pipe.api.E2eApiTextDataFormat text_format = 2;
  bool has_text_format() const;
  private:
  bool _internal_has_text_format() const;
  public:
  void clear_text_format();
  const ::e2e_pipe::api::E2eApiTextDataFormat& text_format() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiTextDataFormat* release_text_format();
  ::e2e_pipe::api::E2eApiTextDataFormat* mutable_text_format();
  void set_allocated_text_format(::e2e_pipe::api::E2eApiTextDataFormat* text_format);
  private:
  const ::e2e_pipe::api::E2eApiTextDataFormat& _internal_text_format() const;
  ::e2e_pipe::api::E2eApiTextDataFormat* _internal_mutable_text_format();
  public:
  void unsafe_arena_set_allocated_text_format(
      ::e2e_pipe::api::E2eApiTextDataFormat* text_format);
  ::e2e_pipe::api::E2eApiTextDataFormat* unsafe_arena_release_text_format();

  // .e2e_pipe.api.E2eApiAudioDataFormat audio_format = 3;
  bool has_audio_format() const;
  private:
  bool _internal_has_audio_format() const;
  public:
  void clear_audio_format();
  const ::e2e_pipe::api::E2eApiAudioDataFormat& audio_format() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiAudioDataFormat* release_audio_format();
  ::e2e_pipe::api::E2eApiAudioDataFormat* mutable_audio_format();
  void set_allocated_audio_format(::e2e_pipe::api::E2eApiAudioDataFormat* audio_format);
  private:
  const ::e2e_pipe::api::E2eApiAudioDataFormat& _internal_audio_format() const;
  ::e2e_pipe::api::E2eApiAudioDataFormat* _internal_mutable_audio_format();
  public:
  void unsafe_arena_set_allocated_audio_format(
      ::e2e_pipe::api::E2eApiAudioDataFormat* audio_format);
  ::e2e_pipe::api::E2eApiAudioDataFormat* unsafe_arena_release_audio_format();

  void clear_format();
  FormatCase format_case() const;
  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiDataFormat)
 private:
  class _Internal;
  void set_has_text_format();
  void set_has_audio_format();

  inline bool has_format() const;
  inline void clear_has_format();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> additional_language_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_code_;
    union FormatUnion {
      constexpr FormatUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::e2e_pipe::api::E2eApiTextDataFormat* text_format_;
      ::e2e_pipe::api::E2eApiAudioDataFormat* audio_format_;
    } format_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiError) */ {
 public:
  inline E2eApiError() : E2eApiError(nullptr) {}
  ~E2eApiError() override;
  explicit PROTOBUF_CONSTEXPR E2eApiError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiError(const E2eApiError& from);
  E2eApiError(E2eApiError&& from) noexcept
    : E2eApiError() {
    *this = ::std::move(from);
  }

  inline E2eApiError& operator=(const E2eApiError& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiError& operator=(E2eApiError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiError& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiError* internal_default_instance() {
    return reinterpret_cast<const E2eApiError*>(
               &_E2eApiError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(E2eApiError& a, E2eApiError& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiError& from) {
    E2eApiError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiError";
  }
  protected:
  explicit E2eApiError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kErrorMessageFieldNumber = 2,
  };
  // string error_code = 1;
  void clear_error_code();
  const std::string& error_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_code();
  PROTOBUF_NODISCARD std::string* release_error_code();
  void set_allocated_error_code(std::string* error_code);
  private:
  const std::string& _internal_error_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_code(const std::string& value);
  std::string* _internal_mutable_error_code();
  public:

  // string error_message = 2;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_code_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiWebhookConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiWebhookConfig) */ {
 public:
  inline E2eApiWebhookConfig() : E2eApiWebhookConfig(nullptr) {}
  ~E2eApiWebhookConfig() override;
  explicit PROTOBUF_CONSTEXPR E2eApiWebhookConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiWebhookConfig(const E2eApiWebhookConfig& from);
  E2eApiWebhookConfig(E2eApiWebhookConfig&& from) noexcept
    : E2eApiWebhookConfig() {
    *this = ::std::move(from);
  }

  inline E2eApiWebhookConfig& operator=(const E2eApiWebhookConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiWebhookConfig& operator=(E2eApiWebhookConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiWebhookConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiWebhookConfig* internal_default_instance() {
    return reinterpret_cast<const E2eApiWebhookConfig*>(
               &_E2eApiWebhookConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(E2eApiWebhookConfig& a, E2eApiWebhookConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiWebhookConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiWebhookConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiWebhookConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiWebhookConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiWebhookConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiWebhookConfig& from) {
    E2eApiWebhookConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiWebhookConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiWebhookConfig";
  }
  protected:
  explicit E2eApiWebhookConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWebhookUrlFieldNumber = 1,
    kPayloadJsonFieldNumber = 2,
  };
  // string webhook_url = 1;
  void clear_webhook_url();
  const std::string& webhook_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_webhook_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_webhook_url();
  PROTOBUF_NODISCARD std::string* release_webhook_url();
  void set_allocated_webhook_url(std::string* webhook_url);
  private:
  const std::string& _internal_webhook_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_webhook_url(const std::string& value);
  std::string* _internal_mutable_webhook_url();
  public:

  // string payload_json = 2;
  void clear_payload_json();
  const std::string& payload_json() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload_json(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload_json();
  PROTOBUF_NODISCARD std::string* release_payload_json();
  void set_allocated_payload_json(std::string* payload_json);
  private:
  const std::string& _internal_payload_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload_json(const std::string& value);
  std::string* _internal_mutable_payload_json();
  public:

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiWebhookConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr webhook_url_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_json_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiInitRequest_OptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<E2eApiInitRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<E2eApiInitRequest_OptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  E2eApiInitRequest_OptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR E2eApiInitRequest_OptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit E2eApiInitRequest_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const E2eApiInitRequest_OptionsEntry_DoNotUse& other);
  static const E2eApiInitRequest_OptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const E2eApiInitRequest_OptionsEntry_DoNotUse*>(&_E2eApiInitRequest_OptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "e2e_pipe.api.E2eApiInitRequest.OptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "e2e_pipe.api.E2eApiInitRequest.OptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};

// -------------------------------------------------------------------

class E2eApiInitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiInitRequest) */ {
 public:
  inline E2eApiInitRequest() : E2eApiInitRequest(nullptr) {}
  ~E2eApiInitRequest() override;
  explicit PROTOBUF_CONSTEXPR E2eApiInitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiInitRequest(const E2eApiInitRequest& from);
  E2eApiInitRequest(E2eApiInitRequest&& from) noexcept
    : E2eApiInitRequest() {
    *this = ::std::move(from);
  }

  inline E2eApiInitRequest& operator=(const E2eApiInitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiInitRequest& operator=(E2eApiInitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiInitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiInitRequest* internal_default_instance() {
    return reinterpret_cast<const E2eApiInitRequest*>(
               &_E2eApiInitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(E2eApiInitRequest& a, E2eApiInitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiInitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiInitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiInitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiInitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiInitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiInitRequest& from) {
    E2eApiInitRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiInitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiInitRequest";
  }
  protected:
  explicit E2eApiInitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 11,
    kClientIdFieldNumber = 1,
    kApiKeyFieldNumber = 2,
    kUserTokenFieldNumber = 9,
    kSourceDataFormatFieldNumber = 5,
    kTargetDataFormatFieldNumber = 6,
    kWebhookConfigFieldNumber = 10,
    kApiTypeFieldNumber = 3,
    kTimelinessFieldNumber = 4,
    kSessionTimeoutFieldNumber = 7,
    kMaxSentenceDurationFieldNumber = 8,
  };
  // map<string, string> options = 11;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_options();

  // string client_id = 1;
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // string api_key = 2;
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_NODISCARD std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // string user_token = 9;
  void clear_user_token();
  const std::string& user_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_token();
  PROTOBUF_NODISCARD std::string* release_user_token();
  void set_allocated_user_token(std::string* user_token);
  private:
  const std::string& _internal_user_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_token(const std::string& value);
  std::string* _internal_mutable_user_token();
  public:

  // .e2e_pipe.api.E2eApiDataFormat source_data_format = 5;
  bool has_source_data_format() const;
  private:
  bool _internal_has_source_data_format() const;
  public:
  void clear_source_data_format();
  const ::e2e_pipe::api::E2eApiDataFormat& source_data_format() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiDataFormat* release_source_data_format();
  ::e2e_pipe::api::E2eApiDataFormat* mutable_source_data_format();
  void set_allocated_source_data_format(::e2e_pipe::api::E2eApiDataFormat* source_data_format);
  private:
  const ::e2e_pipe::api::E2eApiDataFormat& _internal_source_data_format() const;
  ::e2e_pipe::api::E2eApiDataFormat* _internal_mutable_source_data_format();
  public:
  void unsafe_arena_set_allocated_source_data_format(
      ::e2e_pipe::api::E2eApiDataFormat* source_data_format);
  ::e2e_pipe::api::E2eApiDataFormat* unsafe_arena_release_source_data_format();

  // .e2e_pipe.api.E2eApiDataFormat target_data_format = 6;
  bool has_target_data_format() const;
  private:
  bool _internal_has_target_data_format() const;
  public:
  void clear_target_data_format();
  const ::e2e_pipe::api::E2eApiDataFormat& target_data_format() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiDataFormat* release_target_data_format();
  ::e2e_pipe::api::E2eApiDataFormat* mutable_target_data_format();
  void set_allocated_target_data_format(::e2e_pipe::api::E2eApiDataFormat* target_data_format);
  private:
  const ::e2e_pipe::api::E2eApiDataFormat& _internal_target_data_format() const;
  ::e2e_pipe::api::E2eApiDataFormat* _internal_mutable_target_data_format();
  public:
  void unsafe_arena_set_allocated_target_data_format(
      ::e2e_pipe::api::E2eApiDataFormat* target_data_format);
  ::e2e_pipe::api::E2eApiDataFormat* unsafe_arena_release_target_data_format();

  // .e2e_pipe.api.E2eApiWebhookConfig webhook_config = 10;
  bool has_webhook_config() const;
  private:
  bool _internal_has_webhook_config() const;
  public:
  void clear_webhook_config();
  const ::e2e_pipe::api::E2eApiWebhookConfig& webhook_config() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiWebhookConfig* release_webhook_config();
  ::e2e_pipe::api::E2eApiWebhookConfig* mutable_webhook_config();
  void set_allocated_webhook_config(::e2e_pipe::api::E2eApiWebhookConfig* webhook_config);
  private:
  const ::e2e_pipe::api::E2eApiWebhookConfig& _internal_webhook_config() const;
  ::e2e_pipe::api::E2eApiWebhookConfig* _internal_mutable_webhook_config();
  public:
  void unsafe_arena_set_allocated_webhook_config(
      ::e2e_pipe::api::E2eApiWebhookConfig* webhook_config);
  ::e2e_pipe::api::E2eApiWebhookConfig* unsafe_arena_release_webhook_config();

  // .e2e_pipe.api.ApiType api_type = 3;
  void clear_api_type();
  ::e2e_pipe::api::ApiType api_type() const;
  void set_api_type(::e2e_pipe::api::ApiType value);
  private:
  ::e2e_pipe::api::ApiType _internal_api_type() const;
  void _internal_set_api_type(::e2e_pipe::api::ApiType value);
  public:

  // .e2e_pipe.api.Timeliness timeliness = 4;
  void clear_timeliness();
  ::e2e_pipe::api::Timeliness timeliness() const;
  void set_timeliness(::e2e_pipe::api::Timeliness value);
  private:
  ::e2e_pipe::api::Timeliness _internal_timeliness() const;
  void _internal_set_timeliness(::e2e_pipe::api::Timeliness value);
  public:

  // uint32 session_timeout = 7;
  void clear_session_timeout();
  uint32_t session_timeout() const;
  void set_session_timeout(uint32_t value);
  private:
  uint32_t _internal_session_timeout() const;
  void _internal_set_session_timeout(uint32_t value);
  public:

  // uint32 max_sentence_duration = 8;
  void clear_max_sentence_duration();
  uint32_t max_sentence_duration() const;
  void set_max_sentence_duration(uint32_t value);
  private:
  uint32_t _internal_max_sentence_duration() const;
  void _internal_set_max_sentence_duration(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiInitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        E2eApiInitRequest_OptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_token_;
    ::e2e_pipe::api::E2eApiDataFormat* source_data_format_;
    ::e2e_pipe::api::E2eApiDataFormat* target_data_format_;
    ::e2e_pipe::api::E2eApiWebhookConfig* webhook_config_;
    int api_type_;
    int timeliness_;
    uint32_t session_timeout_;
    uint32_t max_sentence_duration_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiInitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiInitResponse) */ {
 public:
  inline E2eApiInitResponse() : E2eApiInitResponse(nullptr) {}
  ~E2eApiInitResponse() override;
  explicit PROTOBUF_CONSTEXPR E2eApiInitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiInitResponse(const E2eApiInitResponse& from);
  E2eApiInitResponse(E2eApiInitResponse&& from) noexcept
    : E2eApiInitResponse() {
    *this = ::std::move(from);
  }

  inline E2eApiInitResponse& operator=(const E2eApiInitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiInitResponse& operator=(E2eApiInitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiInitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiInitResponse* internal_default_instance() {
    return reinterpret_cast<const E2eApiInitResponse*>(
               &_E2eApiInitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(E2eApiInitResponse& a, E2eApiInitResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiInitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiInitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiInitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiInitResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiInitResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiInitResponse& from) {
    E2eApiInitResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiInitResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiInitResponse";
  }
  protected:
  explicit E2eApiInitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kErrorFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .e2e_pipe.api.E2eApiError error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::e2e_pipe::api::E2eApiError& error() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiError* release_error();
  ::e2e_pipe::api::E2eApiError* mutable_error();
  void set_allocated_error(::e2e_pipe::api::E2eApiError* error);
  private:
  const ::e2e_pipe::api::E2eApiError& _internal_error() const;
  ::e2e_pipe::api::E2eApiError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::e2e_pipe::api::E2eApiError* error);
  ::e2e_pipe::api::E2eApiError* unsafe_arena_release_error();

  // .e2e_pipe.api.E2eApiResponseType type = 2;
  void clear_type();
  ::e2e_pipe::api::E2eApiResponseType type() const;
  void set_type(::e2e_pipe::api::E2eApiResponseType value);
  private:
  ::e2e_pipe::api::E2eApiResponseType _internal_type() const;
  void _internal_set_type(::e2e_pipe::api::E2eApiResponseType value);
  public:

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiInitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::e2e_pipe::api::E2eApiError* error_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiTransRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiTransRequest) */ {
 public:
  inline E2eApiTransRequest() : E2eApiTransRequest(nullptr) {}
  ~E2eApiTransRequest() override;
  explicit PROTOBUF_CONSTEXPR E2eApiTransRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiTransRequest(const E2eApiTransRequest& from);
  E2eApiTransRequest(E2eApiTransRequest&& from) noexcept
    : E2eApiTransRequest() {
    *this = ::std::move(from);
  }

  inline E2eApiTransRequest& operator=(const E2eApiTransRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiTransRequest& operator=(E2eApiTransRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiTransRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiTransRequest* internal_default_instance() {
    return reinterpret_cast<const E2eApiTransRequest*>(
               &_E2eApiTransRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(E2eApiTransRequest& a, E2eApiTransRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiTransRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiTransRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiTransRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiTransRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiTransRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiTransRequest& from) {
    E2eApiTransRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiTransRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiTransRequest";
  }
  protected:
  explicit E2eApiTransRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .e2e_pipe.api.E2eApiData data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::e2e_pipe::api::E2eApiData& data() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiData* release_data();
  ::e2e_pipe::api::E2eApiData* mutable_data();
  void set_allocated_data(::e2e_pipe::api::E2eApiData* data);
  private:
  const ::e2e_pipe::api::E2eApiData& _internal_data() const;
  ::e2e_pipe::api::E2eApiData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::e2e_pipe::api::E2eApiData* data);
  ::e2e_pipe::api::E2eApiData* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiTransRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::e2e_pipe::api::E2eApiData* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiTransResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiTransResponse) */ {
 public:
  inline E2eApiTransResponse() : E2eApiTransResponse(nullptr) {}
  ~E2eApiTransResponse() override;
  explicit PROTOBUF_CONSTEXPR E2eApiTransResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiTransResponse(const E2eApiTransResponse& from);
  E2eApiTransResponse(E2eApiTransResponse&& from) noexcept
    : E2eApiTransResponse() {
    *this = ::std::move(from);
  }

  inline E2eApiTransResponse& operator=(const E2eApiTransResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiTransResponse& operator=(E2eApiTransResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiTransResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiTransResponse* internal_default_instance() {
    return reinterpret_cast<const E2eApiTransResponse*>(
               &_E2eApiTransResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(E2eApiTransResponse& a, E2eApiTransResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiTransResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiTransResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiTransResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiTransResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiTransResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiTransResponse& from) {
    E2eApiTransResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiTransResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiTransResponse";
  }
  protected:
  explicit E2eApiTransResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kErrorFieldNumber = 3,
    kDataFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .e2e_pipe.api.E2eApiError error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::e2e_pipe::api::E2eApiError& error() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiError* release_error();
  ::e2e_pipe::api::E2eApiError* mutable_error();
  void set_allocated_error(::e2e_pipe::api::E2eApiError* error);
  private:
  const ::e2e_pipe::api::E2eApiError& _internal_error() const;
  ::e2e_pipe::api::E2eApiError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::e2e_pipe::api::E2eApiError* error);
  ::e2e_pipe::api::E2eApiError* unsafe_arena_release_error();

  // .e2e_pipe.api.E2eApiData data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::e2e_pipe::api::E2eApiData& data() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiData* release_data();
  ::e2e_pipe::api::E2eApiData* mutable_data();
  void set_allocated_data(::e2e_pipe::api::E2eApiData* data);
  private:
  const ::e2e_pipe::api::E2eApiData& _internal_data() const;
  ::e2e_pipe::api::E2eApiData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::e2e_pipe::api::E2eApiData* data);
  ::e2e_pipe::api::E2eApiData* unsafe_arena_release_data();

  // .e2e_pipe.api.E2eApiResponseType type = 2;
  void clear_type();
  ::e2e_pipe::api::E2eApiResponseType type() const;
  void set_type(::e2e_pipe::api::E2eApiResponseType value);
  private:
  ::e2e_pipe::api::E2eApiResponseType _internal_type() const;
  void _internal_set_type(::e2e_pipe::api::E2eApiResponseType value);
  public:

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiTransResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::e2e_pipe::api::E2eApiError* error_;
    ::e2e_pipe::api::E2eApiData* data_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiCloseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiCloseRequest) */ {
 public:
  inline E2eApiCloseRequest() : E2eApiCloseRequest(nullptr) {}
  ~E2eApiCloseRequest() override;
  explicit PROTOBUF_CONSTEXPR E2eApiCloseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiCloseRequest(const E2eApiCloseRequest& from);
  E2eApiCloseRequest(E2eApiCloseRequest&& from) noexcept
    : E2eApiCloseRequest() {
    *this = ::std::move(from);
  }

  inline E2eApiCloseRequest& operator=(const E2eApiCloseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiCloseRequest& operator=(E2eApiCloseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiCloseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiCloseRequest* internal_default_instance() {
    return reinterpret_cast<const E2eApiCloseRequest*>(
               &_E2eApiCloseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(E2eApiCloseRequest& a, E2eApiCloseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiCloseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiCloseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiCloseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiCloseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiCloseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiCloseRequest& from) {
    E2eApiCloseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiCloseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiCloseRequest";
  }
  protected:
  explicit E2eApiCloseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kWaitToDrainFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // bool wait_to_drain = 2;
  void clear_wait_to_drain();
  bool wait_to_drain() const;
  void set_wait_to_drain(bool value);
  private:
  bool _internal_wait_to_drain() const;
  void _internal_set_wait_to_drain(bool value);
  public:

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiCloseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    bool wait_to_drain_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// -------------------------------------------------------------------

class E2eApiCloseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:e2e_pipe.api.E2eApiCloseResponse) */ {
 public:
  inline E2eApiCloseResponse() : E2eApiCloseResponse(nullptr) {}
  ~E2eApiCloseResponse() override;
  explicit PROTOBUF_CONSTEXPR E2eApiCloseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  E2eApiCloseResponse(const E2eApiCloseResponse& from);
  E2eApiCloseResponse(E2eApiCloseResponse&& from) noexcept
    : E2eApiCloseResponse() {
    *this = ::std::move(from);
  }

  inline E2eApiCloseResponse& operator=(const E2eApiCloseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline E2eApiCloseResponse& operator=(E2eApiCloseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const E2eApiCloseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const E2eApiCloseResponse* internal_default_instance() {
    return reinterpret_cast<const E2eApiCloseResponse*>(
               &_E2eApiCloseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(E2eApiCloseResponse& a, E2eApiCloseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(E2eApiCloseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(E2eApiCloseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  E2eApiCloseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<E2eApiCloseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const E2eApiCloseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const E2eApiCloseResponse& from) {
    E2eApiCloseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(E2eApiCloseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "e2e_pipe.api.E2eApiCloseResponse";
  }
  protected:
  explicit E2eApiCloseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kErrorFieldNumber = 3,
    kDataFieldNumber = 4,
    kTypeFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id();
  const std::string& session_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* session_id);
  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(const std::string& value);
  std::string* _internal_mutable_session_id();
  public:

  // .e2e_pipe.api.E2eApiError error = 3;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::e2e_pipe::api::E2eApiError& error() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiError* release_error();
  ::e2e_pipe::api::E2eApiError* mutable_error();
  void set_allocated_error(::e2e_pipe::api::E2eApiError* error);
  private:
  const ::e2e_pipe::api::E2eApiError& _internal_error() const;
  ::e2e_pipe::api::E2eApiError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::e2e_pipe::api::E2eApiError* error);
  ::e2e_pipe::api::E2eApiError* unsafe_arena_release_error();

  // .e2e_pipe.api.E2eApiData data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::e2e_pipe::api::E2eApiData& data() const;
  PROTOBUF_NODISCARD ::e2e_pipe::api::E2eApiData* release_data();
  ::e2e_pipe::api::E2eApiData* mutable_data();
  void set_allocated_data(::e2e_pipe::api::E2eApiData* data);
  private:
  const ::e2e_pipe::api::E2eApiData& _internal_data() const;
  ::e2e_pipe::api::E2eApiData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::e2e_pipe::api::E2eApiData* data);
  ::e2e_pipe::api::E2eApiData* unsafe_arena_release_data();

  // .e2e_pipe.api.E2eApiResponseType type = 2;
  void clear_type();
  ::e2e_pipe::api::E2eApiResponseType type() const;
  void set_type(::e2e_pipe::api::E2eApiResponseType value);
  private:
  ::e2e_pipe::api::E2eApiResponseType _internal_type() const;
  void _internal_set_type(::e2e_pipe::api::E2eApiResponseType value);
  public:

  // @@protoc_insertion_point(class_scope:e2e_pipe.api.E2eApiCloseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::e2e_pipe::api::E2eApiError* error_;
    ::e2e_pipe::api::E2eApiData* data_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_e2e_5fapi_5flayer_5fproto_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// E2eApiData

// bytes audio = 1;
inline bool E2eApiData::_internal_has_audio() const {
  return data_case() == kAudio;
}
inline bool E2eApiData::has_audio() const {
  return _internal_has_audio();
}
inline void E2eApiData::set_has_audio() {
  _impl_._oneof_case_[0] = kAudio;
}
inline void E2eApiData::clear_audio() {
  if (_internal_has_audio()) {
    _impl_.data_.audio_.Destroy();
    clear_has_data();
  }
}
inline const std::string& E2eApiData::audio() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiData.audio)
  return _internal_audio();
}
template <typename ArgT0, typename... ArgT>
inline void E2eApiData::set_audio(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_audio()) {
    clear_data();
    set_has_audio();
    _impl_.data_.audio_.InitDefault();
  }
  _impl_.data_.audio_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiData.audio)
}
inline std::string* E2eApiData::mutable_audio() {
  std::string* _s = _internal_mutable_audio();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiData.audio)
  return _s;
}
inline const std::string& E2eApiData::_internal_audio() const {
  if (_internal_has_audio()) {
    return _impl_.data_.audio_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void E2eApiData::_internal_set_audio(const std::string& value) {
  if (!_internal_has_audio()) {
    clear_data();
    set_has_audio();
    _impl_.data_.audio_.InitDefault();
  }
  _impl_.data_.audio_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiData::_internal_mutable_audio() {
  if (!_internal_has_audio()) {
    clear_data();
    set_has_audio();
    _impl_.data_.audio_.InitDefault();
  }
  return _impl_.data_.audio_.Mutable(      GetArenaForAllocation());
}
inline std::string* E2eApiData::release_audio() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiData.audio)
  if (_internal_has_audio()) {
    clear_has_data();
    return _impl_.data_.audio_.Release();
  } else {
    return nullptr;
  }
}
inline void E2eApiData::set_allocated_audio(std::string* audio) {
  if (has_data()) {
    clear_data();
  }
  if (audio != nullptr) {
    set_has_audio();
    _impl_.data_.audio_.InitAllocated(audio, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiData.audio)
}

// string text = 2;
inline bool E2eApiData::_internal_has_text() const {
  return data_case() == kText;
}
inline bool E2eApiData::has_text() const {
  return _internal_has_text();
}
inline void E2eApiData::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void E2eApiData::clear_text() {
  if (_internal_has_text()) {
    _impl_.data_.text_.Destroy();
    clear_has_data();
  }
}
inline const std::string& E2eApiData::text() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiData.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline void E2eApiData::set_text(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_text()) {
    clear_data();
    set_has_text();
    _impl_.data_.text_.InitDefault();
  }
  _impl_.data_.text_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiData.text)
}
inline std::string* E2eApiData::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiData.text)
  return _s;
}
inline const std::string& E2eApiData::_internal_text() const {
  if (_internal_has_text()) {
    return _impl_.data_.text_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void E2eApiData::_internal_set_text(const std::string& value) {
  if (!_internal_has_text()) {
    clear_data();
    set_has_text();
    _impl_.data_.text_.InitDefault();
  }
  _impl_.data_.text_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiData::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_data();
    set_has_text();
    _impl_.data_.text_.InitDefault();
  }
  return _impl_.data_.text_.Mutable(      GetArenaForAllocation());
}
inline std::string* E2eApiData::release_text() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiData.text)
  if (_internal_has_text()) {
    clear_has_data();
    return _impl_.data_.text_.Release();
  } else {
    return nullptr;
  }
}
inline void E2eApiData::set_allocated_text(std::string* text) {
  if (has_data()) {
    clear_data();
  }
  if (text != nullptr) {
    set_has_text();
    _impl_.data_.text_.InitAllocated(text, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiData.text)
}

// map<string, string> multilingual_text = 7;
inline int E2eApiData::_internal_multilingual_text_size() const {
  return _impl_.multilingual_text_.size();
}
inline int E2eApiData::multilingual_text_size() const {
  return _internal_multilingual_text_size();
}
inline void E2eApiData::clear_multilingual_text() {
  _impl_.multilingual_text_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
E2eApiData::_internal_multilingual_text() const {
  return _impl_.multilingual_text_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
E2eApiData::multilingual_text() const {
  // @@protoc_insertion_point(field_map:e2e_pipe.api.E2eApiData.multilingual_text)
  return _internal_multilingual_text();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
E2eApiData::_internal_mutable_multilingual_text() {
  return _impl_.multilingual_text_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
E2eApiData::mutable_multilingual_text() {
  // @@protoc_insertion_point(field_mutable_map:e2e_pipe.api.E2eApiData.multilingual_text)
  return _internal_mutable_multilingual_text();
}

// bool is_partial = 3;
inline void E2eApiData::clear_is_partial() {
  _impl_.is_partial_ = false;
}
inline bool E2eApiData::_internal_is_partial() const {
  return _impl_.is_partial_;
}
inline bool E2eApiData::is_partial() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiData.is_partial)
  return _internal_is_partial();
}
inline void E2eApiData::_internal_set_is_partial(bool value) {
  
  _impl_.is_partial_ = value;
}
inline void E2eApiData::set_is_partial(bool value) {
  _internal_set_is_partial(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiData.is_partial)
}

// string original = 4;
inline void E2eApiData::clear_original() {
  _impl_.original_.ClearToEmpty();
}
inline const std::string& E2eApiData::original() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiData.original)
  return _internal_original();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiData::set_original(ArgT0&& arg0, ArgT... args) {
 
 _impl_.original_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiData.original)
}
inline std::string* E2eApiData::mutable_original() {
  std::string* _s = _internal_mutable_original();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiData.original)
  return _s;
}
inline const std::string& E2eApiData::_internal_original() const {
  return _impl_.original_.Get();
}
inline void E2eApiData::_internal_set_original(const std::string& value) {
  
  _impl_.original_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiData::_internal_mutable_original() {
  
  return _impl_.original_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiData::release_original() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiData.original)
  return _impl_.original_.Release();
}
inline void E2eApiData::set_allocated_original(std::string* original) {
  if (original != nullptr) {
    
  } else {
    
  }
  _impl_.original_.SetAllocated(original, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.original_.IsDefault()) {
    _impl_.original_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiData.original)
}

// uint64 time_start_msec = 5;
inline void E2eApiData::clear_time_start_msec() {
  _impl_.time_start_msec_ = uint64_t{0u};
}
inline uint64_t E2eApiData::_internal_time_start_msec() const {
  return _impl_.time_start_msec_;
}
inline uint64_t E2eApiData::time_start_msec() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiData.time_start_msec)
  return _internal_time_start_msec();
}
inline void E2eApiData::_internal_set_time_start_msec(uint64_t value) {
  
  _impl_.time_start_msec_ = value;
}
inline void E2eApiData::set_time_start_msec(uint64_t value) {
  _internal_set_time_start_msec(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiData.time_start_msec)
}

// uint64 time_end_msec = 6;
inline void E2eApiData::clear_time_end_msec() {
  _impl_.time_end_msec_ = uint64_t{0u};
}
inline uint64_t E2eApiData::_internal_time_end_msec() const {
  return _impl_.time_end_msec_;
}
inline uint64_t E2eApiData::time_end_msec() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiData.time_end_msec)
  return _internal_time_end_msec();
}
inline void E2eApiData::_internal_set_time_end_msec(uint64_t value) {
  
  _impl_.time_end_msec_ = value;
}
inline void E2eApiData::set_time_end_msec(uint64_t value) {
  _internal_set_time_end_msec(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiData.time_end_msec)
}

inline bool E2eApiData::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void E2eApiData::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline E2eApiData::DataCase E2eApiData::data_case() const {
  return E2eApiData::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// E2eApiTextDataFormat

// -------------------------------------------------------------------

// E2eApiAudioDataFormat

// uint32 sample_rate = 1;
inline void E2eApiAudioDataFormat::clear_sample_rate() {
  _impl_.sample_rate_ = 0u;
}
inline uint32_t E2eApiAudioDataFormat::_internal_sample_rate() const {
  return _impl_.sample_rate_;
}
inline uint32_t E2eApiAudioDataFormat::sample_rate() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiAudioDataFormat.sample_rate)
  return _internal_sample_rate();
}
inline void E2eApiAudioDataFormat::_internal_set_sample_rate(uint32_t value) {
  
  _impl_.sample_rate_ = value;
}
inline void E2eApiAudioDataFormat::set_sample_rate(uint32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiAudioDataFormat.sample_rate)
}

// uint32 channels = 2;
inline void E2eApiAudioDataFormat::clear_channels() {
  _impl_.channels_ = 0u;
}
inline uint32_t E2eApiAudioDataFormat::_internal_channels() const {
  return _impl_.channels_;
}
inline uint32_t E2eApiAudioDataFormat::channels() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiAudioDataFormat.channels)
  return _internal_channels();
}
inline void E2eApiAudioDataFormat::_internal_set_channels(uint32_t value) {
  
  _impl_.channels_ = value;
}
inline void E2eApiAudioDataFormat::set_channels(uint32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiAudioDataFormat.channels)
}

// -------------------------------------------------------------------

// E2eApiDataFormat

// string language_code = 1;
inline void E2eApiDataFormat::clear_language_code() {
  _impl_.language_code_.ClearToEmpty();
}
inline const std::string& E2eApiDataFormat::language_code() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiDataFormat.language_code)
  return _internal_language_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiDataFormat::set_language_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.language_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiDataFormat.language_code)
}
inline std::string* E2eApiDataFormat::mutable_language_code() {
  std::string* _s = _internal_mutable_language_code();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiDataFormat.language_code)
  return _s;
}
inline const std::string& E2eApiDataFormat::_internal_language_code() const {
  return _impl_.language_code_.Get();
}
inline void E2eApiDataFormat::_internal_set_language_code(const std::string& value) {
  
  _impl_.language_code_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiDataFormat::_internal_mutable_language_code() {
  
  return _impl_.language_code_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiDataFormat::release_language_code() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiDataFormat.language_code)
  return _impl_.language_code_.Release();
}
inline void E2eApiDataFormat::set_allocated_language_code(std::string* language_code) {
  if (language_code != nullptr) {
    
  } else {
    
  }
  _impl_.language_code_.SetAllocated(language_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.language_code_.IsDefault()) {
    _impl_.language_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiDataFormat.language_code)
}

// repeated string additional_language_code = 4;
inline int E2eApiDataFormat::_internal_additional_language_code_size() const {
  return _impl_.additional_language_code_.size();
}
inline int E2eApiDataFormat::additional_language_code_size() const {
  return _internal_additional_language_code_size();
}
inline void E2eApiDataFormat::clear_additional_language_code() {
  _impl_.additional_language_code_.Clear();
}
inline std::string* E2eApiDataFormat::add_additional_language_code() {
  std::string* _s = _internal_add_additional_language_code();
  // @@protoc_insertion_point(field_add_mutable:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
  return _s;
}
inline const std::string& E2eApiDataFormat::_internal_additional_language_code(int index) const {
  return _impl_.additional_language_code_.Get(index);
}
inline const std::string& E2eApiDataFormat::additional_language_code(int index) const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
  return _internal_additional_language_code(index);
}
inline std::string* E2eApiDataFormat::mutable_additional_language_code(int index) {
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
  return _impl_.additional_language_code_.Mutable(index);
}
inline void E2eApiDataFormat::set_additional_language_code(int index, const std::string& value) {
  _impl_.additional_language_code_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
}
inline void E2eApiDataFormat::set_additional_language_code(int index, std::string&& value) {
  _impl_.additional_language_code_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
}
inline void E2eApiDataFormat::set_additional_language_code(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.additional_language_code_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
}
inline void E2eApiDataFormat::set_additional_language_code(int index, const char* value, size_t size) {
  _impl_.additional_language_code_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
}
inline std::string* E2eApiDataFormat::_internal_add_additional_language_code() {
  return _impl_.additional_language_code_.Add();
}
inline void E2eApiDataFormat::add_additional_language_code(const std::string& value) {
  _impl_.additional_language_code_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
}
inline void E2eApiDataFormat::add_additional_language_code(std::string&& value) {
  _impl_.additional_language_code_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
}
inline void E2eApiDataFormat::add_additional_language_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.additional_language_code_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
}
inline void E2eApiDataFormat::add_additional_language_code(const char* value, size_t size) {
  _impl_.additional_language_code_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
E2eApiDataFormat::additional_language_code() const {
  // @@protoc_insertion_point(field_list:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
  return _impl_.additional_language_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
E2eApiDataFormat::mutable_additional_language_code() {
  // @@protoc_insertion_point(field_mutable_list:e2e_pipe.api.E2eApiDataFormat.additional_language_code)
  return &_impl_.additional_language_code_;
}

// .e2e_pipe.api.E2eApiTextDataFormat text_format = 2;
inline bool E2eApiDataFormat::_internal_has_text_format() const {
  return format_case() == kTextFormat;
}
inline bool E2eApiDataFormat::has_text_format() const {
  return _internal_has_text_format();
}
inline void E2eApiDataFormat::set_has_text_format() {
  _impl_._oneof_case_[0] = kTextFormat;
}
inline void E2eApiDataFormat::clear_text_format() {
  if (_internal_has_text_format()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.format_.text_format_;
    }
    clear_has_format();
  }
}
inline ::e2e_pipe::api::E2eApiTextDataFormat* E2eApiDataFormat::release_text_format() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiDataFormat.text_format)
  if (_internal_has_text_format()) {
    clear_has_format();
    ::e2e_pipe::api::E2eApiTextDataFormat* temp = _impl_.format_.text_format_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.format_.text_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::e2e_pipe::api::E2eApiTextDataFormat& E2eApiDataFormat::_internal_text_format() const {
  return _internal_has_text_format()
      ? *_impl_.format_.text_format_
      : reinterpret_cast< ::e2e_pipe::api::E2eApiTextDataFormat&>(::e2e_pipe::api::_E2eApiTextDataFormat_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiTextDataFormat& E2eApiDataFormat::text_format() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiDataFormat.text_format)
  return _internal_text_format();
}
inline ::e2e_pipe::api::E2eApiTextDataFormat* E2eApiDataFormat::unsafe_arena_release_text_format() {
  // @@protoc_insertion_point(field_unsafe_arena_release:e2e_pipe.api.E2eApiDataFormat.text_format)
  if (_internal_has_text_format()) {
    clear_has_format();
    ::e2e_pipe::api::E2eApiTextDataFormat* temp = _impl_.format_.text_format_;
    _impl_.format_.text_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eApiDataFormat::unsafe_arena_set_allocated_text_format(::e2e_pipe::api::E2eApiTextDataFormat* text_format) {
  clear_format();
  if (text_format) {
    set_has_text_format();
    _impl_.format_.text_format_ = text_format;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiDataFormat.text_format)
}
inline ::e2e_pipe::api::E2eApiTextDataFormat* E2eApiDataFormat::_internal_mutable_text_format() {
  if (!_internal_has_text_format()) {
    clear_format();
    set_has_text_format();
    _impl_.format_.text_format_ = CreateMaybeMessage< ::e2e_pipe::api::E2eApiTextDataFormat >(GetArenaForAllocation());
  }
  return _impl_.format_.text_format_;
}
inline ::e2e_pipe::api::E2eApiTextDataFormat* E2eApiDataFormat::mutable_text_format() {
  ::e2e_pipe::api::E2eApiTextDataFormat* _msg = _internal_mutable_text_format();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiDataFormat.text_format)
  return _msg;
}

// .e2e_pipe.api.E2eApiAudioDataFormat audio_format = 3;
inline bool E2eApiDataFormat::_internal_has_audio_format() const {
  return format_case() == kAudioFormat;
}
inline bool E2eApiDataFormat::has_audio_format() const {
  return _internal_has_audio_format();
}
inline void E2eApiDataFormat::set_has_audio_format() {
  _impl_._oneof_case_[0] = kAudioFormat;
}
inline void E2eApiDataFormat::clear_audio_format() {
  if (_internal_has_audio_format()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.format_.audio_format_;
    }
    clear_has_format();
  }
}
inline ::e2e_pipe::api::E2eApiAudioDataFormat* E2eApiDataFormat::release_audio_format() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiDataFormat.audio_format)
  if (_internal_has_audio_format()) {
    clear_has_format();
    ::e2e_pipe::api::E2eApiAudioDataFormat* temp = _impl_.format_.audio_format_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.format_.audio_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::e2e_pipe::api::E2eApiAudioDataFormat& E2eApiDataFormat::_internal_audio_format() const {
  return _internal_has_audio_format()
      ? *_impl_.format_.audio_format_
      : reinterpret_cast< ::e2e_pipe::api::E2eApiAudioDataFormat&>(::e2e_pipe::api::_E2eApiAudioDataFormat_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiAudioDataFormat& E2eApiDataFormat::audio_format() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiDataFormat.audio_format)
  return _internal_audio_format();
}
inline ::e2e_pipe::api::E2eApiAudioDataFormat* E2eApiDataFormat::unsafe_arena_release_audio_format() {
  // @@protoc_insertion_point(field_unsafe_arena_release:e2e_pipe.api.E2eApiDataFormat.audio_format)
  if (_internal_has_audio_format()) {
    clear_has_format();
    ::e2e_pipe::api::E2eApiAudioDataFormat* temp = _impl_.format_.audio_format_;
    _impl_.format_.audio_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void E2eApiDataFormat::unsafe_arena_set_allocated_audio_format(::e2e_pipe::api::E2eApiAudioDataFormat* audio_format) {
  clear_format();
  if (audio_format) {
    set_has_audio_format();
    _impl_.format_.audio_format_ = audio_format;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiDataFormat.audio_format)
}
inline ::e2e_pipe::api::E2eApiAudioDataFormat* E2eApiDataFormat::_internal_mutable_audio_format() {
  if (!_internal_has_audio_format()) {
    clear_format();
    set_has_audio_format();
    _impl_.format_.audio_format_ = CreateMaybeMessage< ::e2e_pipe::api::E2eApiAudioDataFormat >(GetArenaForAllocation());
  }
  return _impl_.format_.audio_format_;
}
inline ::e2e_pipe::api::E2eApiAudioDataFormat* E2eApiDataFormat::mutable_audio_format() {
  ::e2e_pipe::api::E2eApiAudioDataFormat* _msg = _internal_mutable_audio_format();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiDataFormat.audio_format)
  return _msg;
}

inline bool E2eApiDataFormat::has_format() const {
  return format_case() != FORMAT_NOT_SET;
}
inline void E2eApiDataFormat::clear_has_format() {
  _impl_._oneof_case_[0] = FORMAT_NOT_SET;
}
inline E2eApiDataFormat::FormatCase E2eApiDataFormat::format_case() const {
  return E2eApiDataFormat::FormatCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// E2eApiError

// string error_code = 1;
inline void E2eApiError::clear_error_code() {
  _impl_.error_code_.ClearToEmpty();
}
inline const std::string& E2eApiError::error_code() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiError.error_code)
  return _internal_error_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiError::set_error_code(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiError.error_code)
}
inline std::string* E2eApiError::mutable_error_code() {
  std::string* _s = _internal_mutable_error_code();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiError.error_code)
  return _s;
}
inline const std::string& E2eApiError::_internal_error_code() const {
  return _impl_.error_code_.Get();
}
inline void E2eApiError::_internal_set_error_code(const std::string& value) {
  
  _impl_.error_code_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiError::_internal_mutable_error_code() {
  
  return _impl_.error_code_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiError::release_error_code() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiError.error_code)
  return _impl_.error_code_.Release();
}
inline void E2eApiError::set_allocated_error_code(std::string* error_code) {
  if (error_code != nullptr) {
    
  } else {
    
  }
  _impl_.error_code_.SetAllocated(error_code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_code_.IsDefault()) {
    _impl_.error_code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiError.error_code)
}

// string error_message = 2;
inline void E2eApiError::clear_error_message() {
  _impl_.error_message_.ClearToEmpty();
}
inline const std::string& E2eApiError::error_message() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiError.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiError::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiError.error_message)
}
inline std::string* E2eApiError::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiError.error_message)
  return _s;
}
inline const std::string& E2eApiError::_internal_error_message() const {
  return _impl_.error_message_.Get();
}
inline void E2eApiError::_internal_set_error_message(const std::string& value) {
  
  _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiError::_internal_mutable_error_message() {
  
  return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiError::release_error_message() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiError.error_message)
  return _impl_.error_message_.Release();
}
inline void E2eApiError::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_message_.IsDefault()) {
    _impl_.error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiError.error_message)
}

// -------------------------------------------------------------------

// E2eApiWebhookConfig

// string webhook_url = 1;
inline void E2eApiWebhookConfig::clear_webhook_url() {
  _impl_.webhook_url_.ClearToEmpty();
}
inline const std::string& E2eApiWebhookConfig::webhook_url() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiWebhookConfig.webhook_url)
  return _internal_webhook_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiWebhookConfig::set_webhook_url(ArgT0&& arg0, ArgT... args) {
 
 _impl_.webhook_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiWebhookConfig.webhook_url)
}
inline std::string* E2eApiWebhookConfig::mutable_webhook_url() {
  std::string* _s = _internal_mutable_webhook_url();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiWebhookConfig.webhook_url)
  return _s;
}
inline const std::string& E2eApiWebhookConfig::_internal_webhook_url() const {
  return _impl_.webhook_url_.Get();
}
inline void E2eApiWebhookConfig::_internal_set_webhook_url(const std::string& value) {
  
  _impl_.webhook_url_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiWebhookConfig::_internal_mutable_webhook_url() {
  
  return _impl_.webhook_url_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiWebhookConfig::release_webhook_url() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiWebhookConfig.webhook_url)
  return _impl_.webhook_url_.Release();
}
inline void E2eApiWebhookConfig::set_allocated_webhook_url(std::string* webhook_url) {
  if (webhook_url != nullptr) {
    
  } else {
    
  }
  _impl_.webhook_url_.SetAllocated(webhook_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.webhook_url_.IsDefault()) {
    _impl_.webhook_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiWebhookConfig.webhook_url)
}

// string payload_json = 2;
inline void E2eApiWebhookConfig::clear_payload_json() {
  _impl_.payload_json_.ClearToEmpty();
}
inline const std::string& E2eApiWebhookConfig::payload_json() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiWebhookConfig.payload_json)
  return _internal_payload_json();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiWebhookConfig::set_payload_json(ArgT0&& arg0, ArgT... args) {
 
 _impl_.payload_json_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiWebhookConfig.payload_json)
}
inline std::string* E2eApiWebhookConfig::mutable_payload_json() {
  std::string* _s = _internal_mutable_payload_json();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiWebhookConfig.payload_json)
  return _s;
}
inline const std::string& E2eApiWebhookConfig::_internal_payload_json() const {
  return _impl_.payload_json_.Get();
}
inline void E2eApiWebhookConfig::_internal_set_payload_json(const std::string& value) {
  
  _impl_.payload_json_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiWebhookConfig::_internal_mutable_payload_json() {
  
  return _impl_.payload_json_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiWebhookConfig::release_payload_json() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiWebhookConfig.payload_json)
  return _impl_.payload_json_.Release();
}
inline void E2eApiWebhookConfig::set_allocated_payload_json(std::string* payload_json) {
  if (payload_json != nullptr) {
    
  } else {
    
  }
  _impl_.payload_json_.SetAllocated(payload_json, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.payload_json_.IsDefault()) {
    _impl_.payload_json_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiWebhookConfig.payload_json)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// E2eApiInitRequest

// string client_id = 1;
inline void E2eApiInitRequest::clear_client_id() {
  _impl_.client_id_.ClearToEmpty();
}
inline const std::string& E2eApiInitRequest::client_id() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiInitRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiInitRequest.client_id)
}
inline std::string* E2eApiInitRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiInitRequest.client_id)
  return _s;
}
inline const std::string& E2eApiInitRequest::_internal_client_id() const {
  return _impl_.client_id_.Get();
}
inline void E2eApiInitRequest::_internal_set_client_id(const std::string& value) {
  
  _impl_.client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiInitRequest::_internal_mutable_client_id() {
  
  return _impl_.client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiInitRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiInitRequest.client_id)
  return _impl_.client_id_.Release();
}
inline void E2eApiInitRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  _impl_.client_id_.SetAllocated(client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiInitRequest.client_id)
}

// string api_key = 2;
inline void E2eApiInitRequest::clear_api_key() {
  _impl_.api_key_.ClearToEmpty();
}
inline const std::string& E2eApiInitRequest::api_key() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiInitRequest::set_api_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.api_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiInitRequest.api_key)
}
inline std::string* E2eApiInitRequest::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiInitRequest.api_key)
  return _s;
}
inline const std::string& E2eApiInitRequest::_internal_api_key() const {
  return _impl_.api_key_.Get();
}
inline void E2eApiInitRequest::_internal_set_api_key(const std::string& value) {
  
  _impl_.api_key_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiInitRequest::_internal_mutable_api_key() {
  
  return _impl_.api_key_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiInitRequest::release_api_key() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiInitRequest.api_key)
  return _impl_.api_key_.Release();
}
inline void E2eApiInitRequest::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    
  } else {
    
  }
  _impl_.api_key_.SetAllocated(api_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.api_key_.IsDefault()) {
    _impl_.api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiInitRequest.api_key)
}

// .e2e_pipe.api.ApiType api_type = 3;
inline void E2eApiInitRequest::clear_api_type() {
  _impl_.api_type_ = 0;
}
inline ::e2e_pipe::api::ApiType E2eApiInitRequest::_internal_api_type() const {
  return static_cast< ::e2e_pipe::api::ApiType >(_impl_.api_type_);
}
inline ::e2e_pipe::api::ApiType E2eApiInitRequest::api_type() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.api_type)
  return _internal_api_type();
}
inline void E2eApiInitRequest::_internal_set_api_type(::e2e_pipe::api::ApiType value) {
  
  _impl_.api_type_ = value;
}
inline void E2eApiInitRequest::set_api_type(::e2e_pipe::api::ApiType value) {
  _internal_set_api_type(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiInitRequest.api_type)
}

// .e2e_pipe.api.Timeliness timeliness = 4;
inline void E2eApiInitRequest::clear_timeliness() {
  _impl_.timeliness_ = 0;
}
inline ::e2e_pipe::api::Timeliness E2eApiInitRequest::_internal_timeliness() const {
  return static_cast< ::e2e_pipe::api::Timeliness >(_impl_.timeliness_);
}
inline ::e2e_pipe::api::Timeliness E2eApiInitRequest::timeliness() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.timeliness)
  return _internal_timeliness();
}
inline void E2eApiInitRequest::_internal_set_timeliness(::e2e_pipe::api::Timeliness value) {
  
  _impl_.timeliness_ = value;
}
inline void E2eApiInitRequest::set_timeliness(::e2e_pipe::api::Timeliness value) {
  _internal_set_timeliness(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiInitRequest.timeliness)
}

// .e2e_pipe.api.E2eApiDataFormat source_data_format = 5;
inline bool E2eApiInitRequest::_internal_has_source_data_format() const {
  return this != internal_default_instance() && _impl_.source_data_format_ != nullptr;
}
inline bool E2eApiInitRequest::has_source_data_format() const {
  return _internal_has_source_data_format();
}
inline void E2eApiInitRequest::clear_source_data_format() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_data_format_ != nullptr) {
    delete _impl_.source_data_format_;
  }
  _impl_.source_data_format_ = nullptr;
}
inline const ::e2e_pipe::api::E2eApiDataFormat& E2eApiInitRequest::_internal_source_data_format() const {
  const ::e2e_pipe::api::E2eApiDataFormat* p = _impl_.source_data_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::e2e_pipe::api::E2eApiDataFormat&>(
      ::e2e_pipe::api::_E2eApiDataFormat_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiDataFormat& E2eApiInitRequest::source_data_format() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.source_data_format)
  return _internal_source_data_format();
}
inline void E2eApiInitRequest::unsafe_arena_set_allocated_source_data_format(
    ::e2e_pipe::api::E2eApiDataFormat* source_data_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_data_format_);
  }
  _impl_.source_data_format_ = source_data_format;
  if (source_data_format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiInitRequest.source_data_format)
}
inline ::e2e_pipe::api::E2eApiDataFormat* E2eApiInitRequest::release_source_data_format() {
  
  ::e2e_pipe::api::E2eApiDataFormat* temp = _impl_.source_data_format_;
  _impl_.source_data_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::e2e_pipe::api::E2eApiDataFormat* E2eApiInitRequest::unsafe_arena_release_source_data_format() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiInitRequest.source_data_format)
  
  ::e2e_pipe::api::E2eApiDataFormat* temp = _impl_.source_data_format_;
  _impl_.source_data_format_ = nullptr;
  return temp;
}
inline ::e2e_pipe::api::E2eApiDataFormat* E2eApiInitRequest::_internal_mutable_source_data_format() {
  
  if (_impl_.source_data_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::e2e_pipe::api::E2eApiDataFormat>(GetArenaForAllocation());
    _impl_.source_data_format_ = p;
  }
  return _impl_.source_data_format_;
}
inline ::e2e_pipe::api::E2eApiDataFormat* E2eApiInitRequest::mutable_source_data_format() {
  ::e2e_pipe::api::E2eApiDataFormat* _msg = _internal_mutable_source_data_format();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiInitRequest.source_data_format)
  return _msg;
}
inline void E2eApiInitRequest::set_allocated_source_data_format(::e2e_pipe::api::E2eApiDataFormat* source_data_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_data_format_;
  }
  if (source_data_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_data_format);
    if (message_arena != submessage_arena) {
      source_data_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_data_format, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_data_format_ = source_data_format;
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiInitRequest.source_data_format)
}

// .e2e_pipe.api.E2eApiDataFormat target_data_format = 6;
inline bool E2eApiInitRequest::_internal_has_target_data_format() const {
  return this != internal_default_instance() && _impl_.target_data_format_ != nullptr;
}
inline bool E2eApiInitRequest::has_target_data_format() const {
  return _internal_has_target_data_format();
}
inline void E2eApiInitRequest::clear_target_data_format() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_data_format_ != nullptr) {
    delete _impl_.target_data_format_;
  }
  _impl_.target_data_format_ = nullptr;
}
inline const ::e2e_pipe::api::E2eApiDataFormat& E2eApiInitRequest::_internal_target_data_format() const {
  const ::e2e_pipe::api::E2eApiDataFormat* p = _impl_.target_data_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::e2e_pipe::api::E2eApiDataFormat&>(
      ::e2e_pipe::api::_E2eApiDataFormat_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiDataFormat& E2eApiInitRequest::target_data_format() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.target_data_format)
  return _internal_target_data_format();
}
inline void E2eApiInitRequest::unsafe_arena_set_allocated_target_data_format(
    ::e2e_pipe::api::E2eApiDataFormat* target_data_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_data_format_);
  }
  _impl_.target_data_format_ = target_data_format;
  if (target_data_format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiInitRequest.target_data_format)
}
inline ::e2e_pipe::api::E2eApiDataFormat* E2eApiInitRequest::release_target_data_format() {
  
  ::e2e_pipe::api::E2eApiDataFormat* temp = _impl_.target_data_format_;
  _impl_.target_data_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::e2e_pipe::api::E2eApiDataFormat* E2eApiInitRequest::unsafe_arena_release_target_data_format() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiInitRequest.target_data_format)
  
  ::e2e_pipe::api::E2eApiDataFormat* temp = _impl_.target_data_format_;
  _impl_.target_data_format_ = nullptr;
  return temp;
}
inline ::e2e_pipe::api::E2eApiDataFormat* E2eApiInitRequest::_internal_mutable_target_data_format() {
  
  if (_impl_.target_data_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::e2e_pipe::api::E2eApiDataFormat>(GetArenaForAllocation());
    _impl_.target_data_format_ = p;
  }
  return _impl_.target_data_format_;
}
inline ::e2e_pipe::api::E2eApiDataFormat* E2eApiInitRequest::mutable_target_data_format() {
  ::e2e_pipe::api::E2eApiDataFormat* _msg = _internal_mutable_target_data_format();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiInitRequest.target_data_format)
  return _msg;
}
inline void E2eApiInitRequest::set_allocated_target_data_format(::e2e_pipe::api::E2eApiDataFormat* target_data_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_data_format_;
  }
  if (target_data_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target_data_format);
    if (message_arena != submessage_arena) {
      target_data_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target_data_format, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_data_format_ = target_data_format;
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiInitRequest.target_data_format)
}

// uint32 session_timeout = 7;
inline void E2eApiInitRequest::clear_session_timeout() {
  _impl_.session_timeout_ = 0u;
}
inline uint32_t E2eApiInitRequest::_internal_session_timeout() const {
  return _impl_.session_timeout_;
}
inline uint32_t E2eApiInitRequest::session_timeout() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.session_timeout)
  return _internal_session_timeout();
}
inline void E2eApiInitRequest::_internal_set_session_timeout(uint32_t value) {
  
  _impl_.session_timeout_ = value;
}
inline void E2eApiInitRequest::set_session_timeout(uint32_t value) {
  _internal_set_session_timeout(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiInitRequest.session_timeout)
}

// uint32 max_sentence_duration = 8;
inline void E2eApiInitRequest::clear_max_sentence_duration() {
  _impl_.max_sentence_duration_ = 0u;
}
inline uint32_t E2eApiInitRequest::_internal_max_sentence_duration() const {
  return _impl_.max_sentence_duration_;
}
inline uint32_t E2eApiInitRequest::max_sentence_duration() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.max_sentence_duration)
  return _internal_max_sentence_duration();
}
inline void E2eApiInitRequest::_internal_set_max_sentence_duration(uint32_t value) {
  
  _impl_.max_sentence_duration_ = value;
}
inline void E2eApiInitRequest::set_max_sentence_duration(uint32_t value) {
  _internal_set_max_sentence_duration(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiInitRequest.max_sentence_duration)
}

// string user_token = 9;
inline void E2eApiInitRequest::clear_user_token() {
  _impl_.user_token_.ClearToEmpty();
}
inline const std::string& E2eApiInitRequest::user_token() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.user_token)
  return _internal_user_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiInitRequest::set_user_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiInitRequest.user_token)
}
inline std::string* E2eApiInitRequest::mutable_user_token() {
  std::string* _s = _internal_mutable_user_token();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiInitRequest.user_token)
  return _s;
}
inline const std::string& E2eApiInitRequest::_internal_user_token() const {
  return _impl_.user_token_.Get();
}
inline void E2eApiInitRequest::_internal_set_user_token(const std::string& value) {
  
  _impl_.user_token_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiInitRequest::_internal_mutable_user_token() {
  
  return _impl_.user_token_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiInitRequest::release_user_token() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiInitRequest.user_token)
  return _impl_.user_token_.Release();
}
inline void E2eApiInitRequest::set_allocated_user_token(std::string* user_token) {
  if (user_token != nullptr) {
    
  } else {
    
  }
  _impl_.user_token_.SetAllocated(user_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_token_.IsDefault()) {
    _impl_.user_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiInitRequest.user_token)
}

// .e2e_pipe.api.E2eApiWebhookConfig webhook_config = 10;
inline bool E2eApiInitRequest::_internal_has_webhook_config() const {
  return this != internal_default_instance() && _impl_.webhook_config_ != nullptr;
}
inline bool E2eApiInitRequest::has_webhook_config() const {
  return _internal_has_webhook_config();
}
inline void E2eApiInitRequest::clear_webhook_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.webhook_config_ != nullptr) {
    delete _impl_.webhook_config_;
  }
  _impl_.webhook_config_ = nullptr;
}
inline const ::e2e_pipe::api::E2eApiWebhookConfig& E2eApiInitRequest::_internal_webhook_config() const {
  const ::e2e_pipe::api::E2eApiWebhookConfig* p = _impl_.webhook_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::e2e_pipe::api::E2eApiWebhookConfig&>(
      ::e2e_pipe::api::_E2eApiWebhookConfig_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiWebhookConfig& E2eApiInitRequest::webhook_config() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitRequest.webhook_config)
  return _internal_webhook_config();
}
inline void E2eApiInitRequest::unsafe_arena_set_allocated_webhook_config(
    ::e2e_pipe::api::E2eApiWebhookConfig* webhook_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.webhook_config_);
  }
  _impl_.webhook_config_ = webhook_config;
  if (webhook_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiInitRequest.webhook_config)
}
inline ::e2e_pipe::api::E2eApiWebhookConfig* E2eApiInitRequest::release_webhook_config() {
  
  ::e2e_pipe::api::E2eApiWebhookConfig* temp = _impl_.webhook_config_;
  _impl_.webhook_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::e2e_pipe::api::E2eApiWebhookConfig* E2eApiInitRequest::unsafe_arena_release_webhook_config() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiInitRequest.webhook_config)
  
  ::e2e_pipe::api::E2eApiWebhookConfig* temp = _impl_.webhook_config_;
  _impl_.webhook_config_ = nullptr;
  return temp;
}
inline ::e2e_pipe::api::E2eApiWebhookConfig* E2eApiInitRequest::_internal_mutable_webhook_config() {
  
  if (_impl_.webhook_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::e2e_pipe::api::E2eApiWebhookConfig>(GetArenaForAllocation());
    _impl_.webhook_config_ = p;
  }
  return _impl_.webhook_config_;
}
inline ::e2e_pipe::api::E2eApiWebhookConfig* E2eApiInitRequest::mutable_webhook_config() {
  ::e2e_pipe::api::E2eApiWebhookConfig* _msg = _internal_mutable_webhook_config();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiInitRequest.webhook_config)
  return _msg;
}
inline void E2eApiInitRequest::set_allocated_webhook_config(::e2e_pipe::api::E2eApiWebhookConfig* webhook_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.webhook_config_;
  }
  if (webhook_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(webhook_config);
    if (message_arena != submessage_arena) {
      webhook_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, webhook_config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.webhook_config_ = webhook_config;
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiInitRequest.webhook_config)
}

// map<string, string> options = 11;
inline int E2eApiInitRequest::_internal_options_size() const {
  return _impl_.options_.size();
}
inline int E2eApiInitRequest::options_size() const {
  return _internal_options_size();
}
inline void E2eApiInitRequest::clear_options() {
  _impl_.options_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
E2eApiInitRequest::_internal_options() const {
  return _impl_.options_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
E2eApiInitRequest::options() const {
  // @@protoc_insertion_point(field_map:e2e_pipe.api.E2eApiInitRequest.options)
  return _internal_options();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
E2eApiInitRequest::_internal_mutable_options() {
  return _impl_.options_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
E2eApiInitRequest::mutable_options() {
  // @@protoc_insertion_point(field_mutable_map:e2e_pipe.api.E2eApiInitRequest.options)
  return _internal_mutable_options();
}

// -------------------------------------------------------------------

// E2eApiInitResponse

// string session_id = 1;
inline void E2eApiInitResponse::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& E2eApiInitResponse::session_id() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitResponse.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiInitResponse::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiInitResponse.session_id)
}
inline std::string* E2eApiInitResponse::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiInitResponse.session_id)
  return _s;
}
inline const std::string& E2eApiInitResponse::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void E2eApiInitResponse::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiInitResponse::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiInitResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiInitResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void E2eApiInitResponse::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiInitResponse.session_id)
}

// .e2e_pipe.api.E2eApiResponseType type = 2;
inline void E2eApiInitResponse::clear_type() {
  _impl_.type_ = 0;
}
inline ::e2e_pipe::api::E2eApiResponseType E2eApiInitResponse::_internal_type() const {
  return static_cast< ::e2e_pipe::api::E2eApiResponseType >(_impl_.type_);
}
inline ::e2e_pipe::api::E2eApiResponseType E2eApiInitResponse::type() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitResponse.type)
  return _internal_type();
}
inline void E2eApiInitResponse::_internal_set_type(::e2e_pipe::api::E2eApiResponseType value) {
  
  _impl_.type_ = value;
}
inline void E2eApiInitResponse::set_type(::e2e_pipe::api::E2eApiResponseType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiInitResponse.type)
}

// .e2e_pipe.api.E2eApiError error = 3;
inline bool E2eApiInitResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool E2eApiInitResponse::has_error() const {
  return _internal_has_error();
}
inline void E2eApiInitResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::e2e_pipe::api::E2eApiError& E2eApiInitResponse::_internal_error() const {
  const ::e2e_pipe::api::E2eApiError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::e2e_pipe::api::E2eApiError&>(
      ::e2e_pipe::api::_E2eApiError_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiError& E2eApiInitResponse::error() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiInitResponse.error)
  return _internal_error();
}
inline void E2eApiInitResponse::unsafe_arena_set_allocated_error(
    ::e2e_pipe::api::E2eApiError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiInitResponse.error)
}
inline ::e2e_pipe::api::E2eApiError* E2eApiInitResponse::release_error() {
  
  ::e2e_pipe::api::E2eApiError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::e2e_pipe::api::E2eApiError* E2eApiInitResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiInitResponse.error)
  
  ::e2e_pipe::api::E2eApiError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::e2e_pipe::api::E2eApiError* E2eApiInitResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::e2e_pipe::api::E2eApiError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::e2e_pipe::api::E2eApiError* E2eApiInitResponse::mutable_error() {
  ::e2e_pipe::api::E2eApiError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiInitResponse.error)
  return _msg;
}
inline void E2eApiInitResponse::set_allocated_error(::e2e_pipe::api::E2eApiError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiInitResponse.error)
}

// -------------------------------------------------------------------

// E2eApiTransRequest

// string session_id = 1;
inline void E2eApiTransRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& E2eApiTransRequest::session_id() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiTransRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiTransRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiTransRequest.session_id)
}
inline std::string* E2eApiTransRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiTransRequest.session_id)
  return _s;
}
inline const std::string& E2eApiTransRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void E2eApiTransRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiTransRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiTransRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiTransRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void E2eApiTransRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiTransRequest.session_id)
}

// .e2e_pipe.api.E2eApiData data = 2;
inline bool E2eApiTransRequest::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool E2eApiTransRequest::has_data() const {
  return _internal_has_data();
}
inline void E2eApiTransRequest::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::e2e_pipe::api::E2eApiData& E2eApiTransRequest::_internal_data() const {
  const ::e2e_pipe::api::E2eApiData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::e2e_pipe::api::E2eApiData&>(
      ::e2e_pipe::api::_E2eApiData_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiData& E2eApiTransRequest::data() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiTransRequest.data)
  return _internal_data();
}
inline void E2eApiTransRequest::unsafe_arena_set_allocated_data(
    ::e2e_pipe::api::E2eApiData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiTransRequest.data)
}
inline ::e2e_pipe::api::E2eApiData* E2eApiTransRequest::release_data() {
  
  ::e2e_pipe::api::E2eApiData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::e2e_pipe::api::E2eApiData* E2eApiTransRequest::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiTransRequest.data)
  
  ::e2e_pipe::api::E2eApiData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::e2e_pipe::api::E2eApiData* E2eApiTransRequest::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::e2e_pipe::api::E2eApiData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::e2e_pipe::api::E2eApiData* E2eApiTransRequest::mutable_data() {
  ::e2e_pipe::api::E2eApiData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiTransRequest.data)
  return _msg;
}
inline void E2eApiTransRequest::set_allocated_data(::e2e_pipe::api::E2eApiData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiTransRequest.data)
}

// -------------------------------------------------------------------

// E2eApiTransResponse

// string session_id = 1;
inline void E2eApiTransResponse::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& E2eApiTransResponse::session_id() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiTransResponse.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiTransResponse::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiTransResponse.session_id)
}
inline std::string* E2eApiTransResponse::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiTransResponse.session_id)
  return _s;
}
inline const std::string& E2eApiTransResponse::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void E2eApiTransResponse::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiTransResponse::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiTransResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiTransResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void E2eApiTransResponse::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiTransResponse.session_id)
}

// .e2e_pipe.api.E2eApiResponseType type = 2;
inline void E2eApiTransResponse::clear_type() {
  _impl_.type_ = 0;
}
inline ::e2e_pipe::api::E2eApiResponseType E2eApiTransResponse::_internal_type() const {
  return static_cast< ::e2e_pipe::api::E2eApiResponseType >(_impl_.type_);
}
inline ::e2e_pipe::api::E2eApiResponseType E2eApiTransResponse::type() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiTransResponse.type)
  return _internal_type();
}
inline void E2eApiTransResponse::_internal_set_type(::e2e_pipe::api::E2eApiResponseType value) {
  
  _impl_.type_ = value;
}
inline void E2eApiTransResponse::set_type(::e2e_pipe::api::E2eApiResponseType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiTransResponse.type)
}

// .e2e_pipe.api.E2eApiError error = 3;
inline bool E2eApiTransResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool E2eApiTransResponse::has_error() const {
  return _internal_has_error();
}
inline void E2eApiTransResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::e2e_pipe::api::E2eApiError& E2eApiTransResponse::_internal_error() const {
  const ::e2e_pipe::api::E2eApiError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::e2e_pipe::api::E2eApiError&>(
      ::e2e_pipe::api::_E2eApiError_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiError& E2eApiTransResponse::error() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiTransResponse.error)
  return _internal_error();
}
inline void E2eApiTransResponse::unsafe_arena_set_allocated_error(
    ::e2e_pipe::api::E2eApiError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiTransResponse.error)
}
inline ::e2e_pipe::api::E2eApiError* E2eApiTransResponse::release_error() {
  
  ::e2e_pipe::api::E2eApiError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::e2e_pipe::api::E2eApiError* E2eApiTransResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiTransResponse.error)
  
  ::e2e_pipe::api::E2eApiError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::e2e_pipe::api::E2eApiError* E2eApiTransResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::e2e_pipe::api::E2eApiError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::e2e_pipe::api::E2eApiError* E2eApiTransResponse::mutable_error() {
  ::e2e_pipe::api::E2eApiError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiTransResponse.error)
  return _msg;
}
inline void E2eApiTransResponse::set_allocated_error(::e2e_pipe::api::E2eApiError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiTransResponse.error)
}

// .e2e_pipe.api.E2eApiData data = 4;
inline bool E2eApiTransResponse::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool E2eApiTransResponse::has_data() const {
  return _internal_has_data();
}
inline void E2eApiTransResponse::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::e2e_pipe::api::E2eApiData& E2eApiTransResponse::_internal_data() const {
  const ::e2e_pipe::api::E2eApiData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::e2e_pipe::api::E2eApiData&>(
      ::e2e_pipe::api::_E2eApiData_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiData& E2eApiTransResponse::data() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiTransResponse.data)
  return _internal_data();
}
inline void E2eApiTransResponse::unsafe_arena_set_allocated_data(
    ::e2e_pipe::api::E2eApiData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiTransResponse.data)
}
inline ::e2e_pipe::api::E2eApiData* E2eApiTransResponse::release_data() {
  
  ::e2e_pipe::api::E2eApiData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::e2e_pipe::api::E2eApiData* E2eApiTransResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiTransResponse.data)
  
  ::e2e_pipe::api::E2eApiData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::e2e_pipe::api::E2eApiData* E2eApiTransResponse::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::e2e_pipe::api::E2eApiData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::e2e_pipe::api::E2eApiData* E2eApiTransResponse::mutable_data() {
  ::e2e_pipe::api::E2eApiData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiTransResponse.data)
  return _msg;
}
inline void E2eApiTransResponse::set_allocated_data(::e2e_pipe::api::E2eApiData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiTransResponse.data)
}

// -------------------------------------------------------------------

// E2eApiCloseRequest

// string session_id = 1;
inline void E2eApiCloseRequest::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& E2eApiCloseRequest::session_id() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiCloseRequest.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiCloseRequest::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiCloseRequest.session_id)
}
inline std::string* E2eApiCloseRequest::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiCloseRequest.session_id)
  return _s;
}
inline const std::string& E2eApiCloseRequest::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void E2eApiCloseRequest::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiCloseRequest::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiCloseRequest::release_session_id() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiCloseRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void E2eApiCloseRequest::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiCloseRequest.session_id)
}

// bool wait_to_drain = 2;
inline void E2eApiCloseRequest::clear_wait_to_drain() {
  _impl_.wait_to_drain_ = false;
}
inline bool E2eApiCloseRequest::_internal_wait_to_drain() const {
  return _impl_.wait_to_drain_;
}
inline bool E2eApiCloseRequest::wait_to_drain() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiCloseRequest.wait_to_drain)
  return _internal_wait_to_drain();
}
inline void E2eApiCloseRequest::_internal_set_wait_to_drain(bool value) {
  
  _impl_.wait_to_drain_ = value;
}
inline void E2eApiCloseRequest::set_wait_to_drain(bool value) {
  _internal_set_wait_to_drain(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiCloseRequest.wait_to_drain)
}

// -------------------------------------------------------------------

// E2eApiCloseResponse

// string session_id = 1;
inline void E2eApiCloseResponse::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& E2eApiCloseResponse::session_id() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiCloseResponse.session_id)
  return _internal_session_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void E2eApiCloseResponse::set_session_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.session_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiCloseResponse.session_id)
}
inline std::string* E2eApiCloseResponse::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiCloseResponse.session_id)
  return _s;
}
inline const std::string& E2eApiCloseResponse::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void E2eApiCloseResponse::_internal_set_session_id(const std::string& value) {
  
  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* E2eApiCloseResponse::_internal_mutable_session_id() {
  
  return _impl_.session_id_.Mutable(GetArenaForAllocation());
}
inline std::string* E2eApiCloseResponse::release_session_id() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiCloseResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void E2eApiCloseResponse::set_allocated_session_id(std::string* session_id) {
  if (session_id != nullptr) {
    
  } else {
    
  }
  _impl_.session_id_.SetAllocated(session_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.session_id_.IsDefault()) {
    _impl_.session_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiCloseResponse.session_id)
}

// .e2e_pipe.api.E2eApiResponseType type = 2;
inline void E2eApiCloseResponse::clear_type() {
  _impl_.type_ = 0;
}
inline ::e2e_pipe::api::E2eApiResponseType E2eApiCloseResponse::_internal_type() const {
  return static_cast< ::e2e_pipe::api::E2eApiResponseType >(_impl_.type_);
}
inline ::e2e_pipe::api::E2eApiResponseType E2eApiCloseResponse::type() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiCloseResponse.type)
  return _internal_type();
}
inline void E2eApiCloseResponse::_internal_set_type(::e2e_pipe::api::E2eApiResponseType value) {
  
  _impl_.type_ = value;
}
inline void E2eApiCloseResponse::set_type(::e2e_pipe::api::E2eApiResponseType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:e2e_pipe.api.E2eApiCloseResponse.type)
}

// .e2e_pipe.api.E2eApiError error = 3;
inline bool E2eApiCloseResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool E2eApiCloseResponse::has_error() const {
  return _internal_has_error();
}
inline void E2eApiCloseResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::e2e_pipe::api::E2eApiError& E2eApiCloseResponse::_internal_error() const {
  const ::e2e_pipe::api::E2eApiError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::e2e_pipe::api::E2eApiError&>(
      ::e2e_pipe::api::_E2eApiError_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiError& E2eApiCloseResponse::error() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiCloseResponse.error)
  return _internal_error();
}
inline void E2eApiCloseResponse::unsafe_arena_set_allocated_error(
    ::e2e_pipe::api::E2eApiError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiCloseResponse.error)
}
inline ::e2e_pipe::api::E2eApiError* E2eApiCloseResponse::release_error() {
  
  ::e2e_pipe::api::E2eApiError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::e2e_pipe::api::E2eApiError* E2eApiCloseResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiCloseResponse.error)
  
  ::e2e_pipe::api::E2eApiError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::e2e_pipe::api::E2eApiError* E2eApiCloseResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::e2e_pipe::api::E2eApiError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::e2e_pipe::api::E2eApiError* E2eApiCloseResponse::mutable_error() {
  ::e2e_pipe::api::E2eApiError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiCloseResponse.error)
  return _msg;
}
inline void E2eApiCloseResponse::set_allocated_error(::e2e_pipe::api::E2eApiError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiCloseResponse.error)
}

// .e2e_pipe.api.E2eApiData data = 4;
inline bool E2eApiCloseResponse::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool E2eApiCloseResponse::has_data() const {
  return _internal_has_data();
}
inline void E2eApiCloseResponse::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::e2e_pipe::api::E2eApiData& E2eApiCloseResponse::_internal_data() const {
  const ::e2e_pipe::api::E2eApiData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::e2e_pipe::api::E2eApiData&>(
      ::e2e_pipe::api::_E2eApiData_default_instance_);
}
inline const ::e2e_pipe::api::E2eApiData& E2eApiCloseResponse::data() const {
  // @@protoc_insertion_point(field_get:e2e_pipe.api.E2eApiCloseResponse.data)
  return _internal_data();
}
inline void E2eApiCloseResponse::unsafe_arena_set_allocated_data(
    ::e2e_pipe::api::E2eApiData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:e2e_pipe.api.E2eApiCloseResponse.data)
}
inline ::e2e_pipe::api::E2eApiData* E2eApiCloseResponse::release_data() {
  
  ::e2e_pipe::api::E2eApiData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::e2e_pipe::api::E2eApiData* E2eApiCloseResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:e2e_pipe.api.E2eApiCloseResponse.data)
  
  ::e2e_pipe::api::E2eApiData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::e2e_pipe::api::E2eApiData* E2eApiCloseResponse::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::e2e_pipe::api::E2eApiData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::e2e_pipe::api::E2eApiData* E2eApiCloseResponse::mutable_data() {
  ::e2e_pipe::api::E2eApiData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:e2e_pipe.api.E2eApiCloseResponse.data)
  return _msg;
}
inline void E2eApiCloseResponse::set_allocated_data(::e2e_pipe::api::E2eApiData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:e2e_pipe.api.E2eApiCloseResponse.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace e2e_pipe

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::e2e_pipe::api::ApiType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::e2e_pipe::api::ApiType>() {
  return ::e2e_pipe::api::ApiType_descriptor();
}
template <> struct is_proto_enum< ::e2e_pipe::api::Timeliness> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::e2e_pipe::api::Timeliness>() {
  return ::e2e_pipe::api::Timeliness_descriptor();
}
template <> struct is_proto_enum< ::e2e_pipe::api::E2eApiResponseType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::e2e_pipe::api::E2eApiResponseType>() {
  return ::e2e_pipe::api::E2eApiResponseType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_e2e_5fapi_5flayer_5fproto_2eproto
